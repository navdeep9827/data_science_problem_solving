# -*- coding: utf-8 -*-
"""LE3_queue_using_arrays.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qYViAa8Y_cLlQt8Oy92RfgN6UP8AjeVp
"""

def evaluate_postfix_expression(postfix_expression, stack):
    # your code here
    operators = set("+-*/^")

    for char in postfix_expression:
        if char.isdigit():  # Operand: push to stack
            stack.push(int(char))
        elif char in operators:  # Operator: pop two operands, perform operation, and push result
            operand2 = stack.pop()
            operand1 = stack.pop()

            if char == '+':
                stack.push(operand1 + operand2)
            elif char == '-':
                stack.push(operand1 - operand2)
            elif char == '*':
                stack.push(operand1 * operand2)
            elif char == '/':
                if operand2 == 0:
                    #raise ValueError("Division by zero in postfix expression.")
                    print("Warning: Division by zero encountered. Returning None.")
                    return None
                stack.push(int(operand1 / operand2))  # For integer division
            elif char == '^':
                stack.push(operand1 ** operand2)

    return stack.top()

if __name__ == "__main__":
    # Example usage:
    infix_expression = "5+4*3"
    s1 = ArrayStack(len(infix_expression))
    postfix_expression = infix_to_postfix(infix_expression, s1)
    s2 = ArrayStack(len(postfix_expression))
    result = evaluate_postfix_expression(postfix_expression, s2)
    print("Result:", result)
    if result == 17:
        print('Test passed')


import numpy as np
class QueueUsingArrays:
    def __init__(self, initial_capacity):
        # your code here
        self.capacity = initial_capacity
        self.queue = np.empty(self.capacity, dtype=object)
        self.front = -1  # Indicates the front of the queue
        self.rear = -1   # Indicates the rear of the queue
        self.current_size = 0

    # Adding an element happens at the rear of the array because it follows FIFO
    def enqueue(self, data):
        # your code here
        if self.isFull():
            print("Queue is full. Cannot enqueue.")
            return

        # If queue is empty, initialize front and rear to 0
        if self.isEmpty():
            self.front = 0
            self.rear = 0
        else:
            self.rear = (self.rear + 1) % self.capacity

        self.queue[self.rear] = data
        self.current_size += 1


    # Function to delete an element from the front of the queue
    def dequeue(self):
        # your code here
        if self.isEmpty():
            print("Queue is empty. Cannot dequeue.")
            return None

        removed_element = self.queue[self.front]

        # If there's only one element
        if self.front == self.rear:
            self.front = -1
            self.rear = -1
        else:
            self.front = (self.front + 1) % self.capacity

        self.current_size -= 1
        return removed_element

    # Function to check if the queue is empty or not
    def isEmpty(self):
        # your code here
        return self.current_size == 0


    # Function to check if the queue is full or not
    def isFull(self):
        # your code here
        return self.current_size == self.capacity


    # Return front of queue
    def peek(self):
        # your code here
        if self.isEmpty():
            print("Queue is empty. Cannot peek.")
            return None
        return self.queue[self.front]



    # returns the size of the queue
    def size(self):
        # your code here
        return self.current_size