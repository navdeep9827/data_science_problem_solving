# -*- coding: utf-8 -*-
"""LE6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hqkMj1IfczwZuGbjZjH-VUPonFpoX6H3

# **Consecutive parent-child numbers**

Given the root of a Binary tree, return the number of parent-child pairs which are consecutive numbers such that *parent = child - 1*.


Example :


    Input:

         4
        / \
       8   5
      /  \
     9   77


    Output: 2

    Explanation : There are only 2 pairs of parent-child which are consecutive numbers.
    Tha pairs are (4, 5) and (8, 9)
"""

# Consecutive parent-child numbers in a binary tree

class Node:
  def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None

# Write this function to return the number of parent-child pairs
# which are consecutive numbers

# Comment out pass and write the code here
def consecutiveNodes(root):
    def dfs(node, parent):
        nonlocal count
        if not node:
            return
        if parent and node.val == parent + 1:
            count += 1
        dfs(node.left, node.val)
        dfs(node.right, node.val)

    count = 0
    dfs(root, None)
    return count

# Execute this codeblock to verify your results

if __name__ == '__main__':
    root = Node(16)
    root.left = Node(17)
    root.right = Node(30)
    root.left.left = Node(18)
    root.left.right = Node(25)
    root.right.left = Node(87)
    root.right.right = Node(31)
    root.left.left.left = Node(45)
    root.left.left.right = Node(19)
    root.left.right.left = Node(26)
    root.left.right.right = Node(90)
    root.right.left.left = Node(76)
    root.right.left.right = Node(66)
    root.right.right.left = Node(27)
    root.right.right.right = Node(32)

    print(consecutiveNodes(root))

"""# **Reverse Level Order Traversal**

Given the root of a Binary tree, return the Reverse Level Order Traversal i.e. starting from bottommost level, traverse from left to right nodes and move up till you reach the root.


Example :


    Input:

         4
        / \
       8   71
          /  \
         96   34


    Output: [96, 34, 8, 71, 4]

    Explanation: Level 3 -> 96, 34. Level 2 -> 8, 71 and Level 1 -> 4
    So, the overall reverse level order traversal is [96, 34, 8, 71, 4]
"""

# Reverse Level Order Traversal

# Comment out pass and write your code here
def reverseLevelOrder(root):
  if not root:
        return []

  result = []
  queue = [root]

  while queue:
        node = queue.pop(0)  # Dequeue the first node in the queue

        # Insert the node's value at the beginning of the result list
        result.insert(0, node.val)

        # Enqueue the child nodes from right to left
        if node.right:
            queue.append(node.right)
        if node.left:
            queue.append(node.left)

  return result
  pass

# Execute this codeblock to verify your results

if __name__ == '__main__':
    root = Node(16)
    root.left = Node(17)
    root.right = Node(30)
    root.left.left = Node(18)
    root.left.right = Node(25)
    root.right.left = Node(87)
    root.right.right = Node(31)
    root.left.left.left = Node(45)
    root.left.left.right = Node(19)
    root.left.right.left = Node(26)
    root.left.right.right = Node(90)
    root.right.left.left = Node(76)
    root.right.left.right = Node(66)
    root.right.right.left = Node(27)
    root.right.right.right = Node(32)

    print(reverseLevelOrder(root))

